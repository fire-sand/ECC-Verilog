0000 | 59800 | 01011001100000000000 | CONST R6 #0 ; R6 <- 0 Both P or Both N 
0001 | 383C0 | 00111000001111000000 | ADD R0 R30 #0 
0002 | 2881F | 00101000100000011111 | ADD R2 R0 R31 
0003 | B8000 | 10111000000000000000 | SCAR 
0004 | 28C1F | 00101000110000011111 | ADD R3 R0 R31 
0005 | B8000 | 10111000000000000000 | SCAR 
0006 | C0000 | 11000000000000000000 | GCAR ; R2 zp 
0007 | 10005 | 00010000000000000101 | BRzp LBL_R3 ; if r2 is 0 or pos then branch 
0008 | A0040 | 10100000000001000000 | TCS R2 R2 ; R2 is negative so invert 
0009 | 98060 | 10011000000001100000 | CHKH R3 ; is R3 0 or pos 
000a | 10005 | 00010000000000000101 | BRzp LBL_R2N ; if R3 is 0 or pos then branch 
000b | A0060 | 10100000000001100000 | TCS R3 R3 ; R3 is negative so invert 
000c | 10004 | 00010000000000000100 | BRzp LBL_MULT ; flipped both so can go straight to mult 
000d | 98060 | 10011000000001100000 | CHKH R3 ; R2 is pos need to check R3 
000e | 10002 | 00010000000000000010 | BRzp LBL_MULT ; if r3 is also pos or 0 
000f | A0060 | 10100000000001100000 | TCS R3 R3 ; r3 is negative so invert 
0010 | 59801 | 01011001100000000001 | CONST R6 #1 ; need to set flag to invert at the end only one was neg 
0011 | 580FF | 01011000000011111111 | CONST R0 #255 
0012 | 38001 | 00111000000000000001 | ADD R0 R0 #1 ; N = 256 
0013 | 58400 | 01011000010000000000 | CONST R1 #0 ; A = 0; 
0014 | 80040 | 10000000000001000000 | CHKL R2 ; Check lowest bit of Q 
0015 | 08001 | 00001000000000000001 | BRz LBL_F ; Yes/No 
0016 | 28423 | 00101000010000100011 | ADD R1 R1 R3 ; A <- A + B 
0017 | 78822 | 01111000100000100010 | SDRL R2 R1 R2 ; Shift A_Q right 
0018 | 70422 | 01110000010000100010 | SDRH R1 R1 R2 ; Shift A_Q right 
0019 | 3801F | 00111000000000011111 | ADD R0 R0 #-1 ; N <- N - 1 
001a | 181F9 | 00011000000111111001 | BRnp CHECK_SR ; N == 0? 
001b | C0000 | 11000000000000000000 | GCAR ; is R0 0 or 1 
001c | 08002 | 00001000000000000010 | BRz LBL_END_MULT 
001d | A0040 | 10100000000001000000 | TCS R2 ; R2 is low bits 
001e | A8020 | 10101000000000100000 | TCDH R1 ; R1 is high bits 
001f | 28022 | 00101000000000100010 | ADD R0 R1 R2 ; check the values 
0020 | 88000 | 10001000000000000000 | DONE ; Return 
