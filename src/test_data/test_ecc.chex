0000 | 5E000 | 01011110000000000000 | CONST R24 #0 
0001 | 5E401 | 01011110010000000001 | CONST R25 #1 
0002 | 5E801 | 01011110100000000001 | CONST R26 #1 
0003 | 5EC00 | 01011110110000000000 | CONST R27 #0 
0004 | 9C620 | 10011100011000100000 | CHKH R17 ; Check if R17 is 0 
0005 | 0800F | 00001000000000001111 | BRz END_LABEL 
0006 | 3F300 | 00111111001100000000 | ADD R28 R24 #0 
0007 | 3F720 | 00111111011100100000 | ADD R29 R25 #0 
0008 | 3FB40 | 00111111101101000000 | ADD R30 R26 #0 
0009 | 3FF60 | 00111111111101100000 | ADD R31 R27 #0 
000a | 4000F | 01000000000000001111 | JSR POINT_ADD_SR 
000b | 48221 | 01001000001000100001 | AND R0 R17 #1 
000c | 20005 | 00100000000000000101 | BRnz SHIFT_N 
000d | 3F240 | 00111111001001000000 | ADD R28 R18 #0 
000e | 3F660 | 00111111011001100000 | ADD R29 R19 #0 
000f | 3FA80 | 00111111101010000000 | ADD R30 R20 #0 
0010 | 3FEA0 | 00111111111010100000 | ADD R31 R21 #0 
0011 | 40008 | 01000000000000001000 | JSR POINT_ADD_SR 
0012 | 6C621 | 01101100011000100001 | SRL R17 R17 #1 
0013 | C0000 | 11000000000000000000 | DEC 
0014 | 181F1 | 00011000000111110001 | BRnp ED_LOOP 
0015 | 3E300 | 00111110001100000000 | ADD R24 R24 #0 
0016 | 3E720 | 00111110011100100000 | ADD R25 R25 #0 
0017 | 3EB40 | 00111110101101000000 | ADD R26 R26 #0 
0018 | 3EF60 | 00111110111101100000 | ADD R27 R27 #0 
0019 | 88000 | 10001000000000000000 | DONE ; end of prog 
001a | 38320 | 00111000001100100000 | ADD R0 R25 #0 ; R0 <- Y1 Need to do this move because of Proc 
001b | 3D8E0 | 00111101100011100000 | ADD R22 R7 #0 ; Save PC of RET 
001c | 30818 | 00110000100000011000 | SUB R2 R0 R24 ; R2 <- Y1 - X1 
001d | B9000 | 10111001000000000000 | GCAR R4 ; Get carry from subtraction 
001e | 58400 | 01011000010000000000 | CONST R1 #0 ; 0 out R1 
001f | 30424 | 00110000010000100100 | SUB R1 R1 R4 ; sign extend subtraction 
0020 | 40087 | 01000000000010000111 | JSR MOD_SR ; mod subtraction 
0021 | 39800 | 00111001100000000000 | ADD R6 R0 #0 ; put result in R6 
0022 | 383A0 | 00111000001110100000 | ADD R0 R29 #0 ; R0 <- Y2 Need to do this because of Proc 
0023 | 3081C | 00110000100000011100 | SUB R2 R0 R28 ; R2 <- Y2 - X2 
0024 | B9000 | 10111001000000000000 | GCAR R4 ; Get carry from subtraction 
0025 | 58400 | 01011000010000000000 | CONST R1 #0 ; 0 out R1 
0026 | 30424 | 00110000010000100100 | SUB R1 R1 R4 ; sign extend subtraction 
0027 | 40080 | 01000000000010000000 | JSR MOD_SR ; mod subtraction 
0028 | 38800 | 00111000100000000000 | ADD R2 R0 #0 ; put result in R2 
0029 | 38CC0 | 00111000110011000000 | ADD R3 R6 #0 ; put first sub in R3 
002a | 59000 | 01011001000000000000 | CONST R4 #0 ; 0 out R4 
002b | 59400 | 01011001010000000000 | CONST R5 #0 ; 0 out R5 
002c | 4005C | 01000000000001011100 | JSR MULT_SR ; Mult result in R1 R2 
002d | 4007A | 01000000000001111010 | JSR MOD_SR ; Mod result in R0 
002e | 3A000 | 00111010000000000000 | ADD R8 R0 #0 ; R8 <- A 
002f | 38320 | 00111000001100100000 | ADD R0 R25 #0 ; R0 <- Y1 Need to do this move because of Proc 
0030 | 28818 | 00101000100000011000 | ADD R2 R0 R24 ; R2 <- Y1 + X1 
0031 | B9000 | 10111001000000000000 | GCAR R4 
0032 | 383A0 | 00111000001110100000 | ADD R0 R29 #0 ; R0 <- Y2 Need to do this because of Proc 
0033 | 28C1C | 00101000110000011100 | ADD R3 R0 R28 ; R3 <- Y2 + X2 
0034 | B9400 | 10111001010000000000 | GCAR R5 
0035 | 40053 | 01000000000001010011 | JSR MULT_SR ; Mult result in R1 R2 
0036 | 40071 | 01000000000001110001 | JSR MOD_SR ; Mod result in R0 
0037 | 3A400 | 00111010010000000000 | ADD R9 R0 #0 ; R9 <- B 
0038 | 59000 | 01011001000000000000 | CONST R4 #0 ; 
0039 | 59400 | 01011001010000000000 | CONST R5 #0 ; 
003a | 38B60 | 00111000101101100000 | ADD R2 R27 #0 ; R2 <- T1 
003b | 38EE0 | 00111000111011100000 | ADD R3 R23 #0 ; R3 <- 2*d 
003c | 4004C | 01000000000001001100 | JSR MULT_SR ; Mult result in R1 R2 
003d | 4006A | 01000000000001101010 | JSR MOD_SR ; Mod result in R0 
003e | 38800 | 00111000100000000000 | ADD R2 R0 #0 ; R2 <- R0 
003f | 38FE0 | 00111000111111100000 | ADD R3 R31 #0 ; R3 <- T2 
0040 | 59000 | 01011001000000000000 | CONST R4 #0 ; 
0041 | 59400 | 01011001010000000000 | CONST R5 #0 ; 
0042 | 40046 | 01000000000001000110 | JSR MULT_SR ; Mult result in R1 R2 
0043 | 40064 | 01000000000001100100 | JSR MOD_SR ; Mod result in R0 
0044 | 3A800 | 00111010100000000000 | ADD R10 R0 #0 ; R10 <- C 
0045 | 60B41 | 01100000101101000001 | SLL R2 R26 #1 ; R2 <- Z1 * 2 ;; BUG May not work with overflow 
0046 | 58400 | 01011000010000000000 | CONST R1 #0 ; R1 <- 0 for mod 
0047 | 40060 | 01000000000001100000 | JSR MOD_SR ; Mod result in R0 
0048 | 38800 | 00111000100000000000 | ADD R2 R0 #0 ; R2 <- mod result 
0049 | 38FC0 | 00111000111111000000 | ADD R3 R30 #0 ; R3 <- Z2 
004a | 59000 | 01011001000000000000 | CONST R4 #0 ; 
004b | 59400 | 01011001010000000000 | CONST R5 #0 ; 
004c | 4003C | 01000000000000111100 | JSR MULT_SR ; Mult result in R1 R2 
004d | 4005A | 01000000000001011010 | JSR MOD_SR ; Mod result in R0 
004e | 3AC00 | 00111010110000000000 | ADD R11 R0 #0 ; R11 <- D 
004f | 38120 | 00111000000100100000 | ADD R0 R9 #0 ; R0 <- B 
0050 | 30808 | 00110000100000001000 | SUB R2 R0 R8 ; R2 <- B - A 
0051 | B9000 | 10111001000000000000 | GCAR R4 
0052 | 58400 | 01011000010000000000 | CONST R1 #0 ; R1 <- 0 for mod 
0053 | 30424 | 00110000010000100100 | SUB R1 R1 R4 ; Handles negative numbers for sub 
0054 | 40053 | 01000000000001010011 | JSR MOD_SR ; Mod result in R0 
0055 | 3B000 | 00111011000000000000 | ADD R12 R0 #0 ; R12 <- E 
0056 | 38160 | 00111000000101100000 | ADD R0 R11 #0 ; R0 <- D 
0057 | 3080A | 00110000100000001010 | SUB R2 R0 R10 ; R2 <- D - C 
0058 | B9000 | 10111001000000000000 | GCAR R4 
0059 | 58400 | 01011000010000000000 | CONST R1 #0 ; R1 <- 0 for mod 
005a | 30424 | 00110000010000100100 | SUB R1 R1 R4 ; Handles negative numbers for sub 
005b | 4004C | 01000000000001001100 | JSR MOD_SR ; Mod result in R0 
005c | 3B400 | 00111011010000000000 | ADD R13 R0 #0 ; R13 <- F 
005d | 38160 | 00111000000101100000 | ADD R0 R11 #0 ; R0 <- D 
005e | 2880A | 00101000100000001010 | ADD R2 R0 R10 ; R2 <- D + C 
005f | B8400 | 10111000010000000000 | GCAR R1 ; putting carry in r1 for mod 
0060 | 40047 | 01000000000001000111 | JSR MOD_SR ; Mod result in R0 
0061 | 3B800 | 00111011100000000000 | ADD R14 R0 #0 ; R14 <- G 
0062 | 38120 | 00111000000100100000 | ADD R0 R9 #0 ; R0 <- B 
0063 | 28808 | 00101000100000001000 | ADD R2 R0 R8 ; R2 <- B - A 
0064 | B8400 | 10111000010000000000 | GCAR R1 ; 
0065 | 40042 | 01000000000001000010 | JSR MOD_SR ; Mod result in R0 
0066 | 3BC00 | 00111011110000000000 | ADD R15 R0 #0 ; R15 <- H 
0067 | 38980 | 00111000100110000000 | ADD R2 R12 #0 ; R2 <- E 
0068 | 38DA0 | 00111000110110100000 | ADD R3 R13 #0 ; R2 <- F 
0069 | 59000 | 01011001000000000000 | CONST R4 #0 ; 
006a | 59400 | 01011001010000000000 | CONST R5 #0 ; 
006b | 4001D | 01000000000000011101 | JSR MULT_SR ; Mult result in R1 R2 
006c | 4003B | 01000000000000111011 | JSR MOD_SR ; Mod result in R0 
006d | 3E000 | 00111110000000000000 | ADD R24 R0 #0 ; X1 <- X3 
006e | 389C0 | 00111000100111000000 | ADD R2 R14 #0 ; R2 <- G 
006f | 38DE0 | 00111000110111100000 | ADD R3 R15 #0 ; R2 <- H 
0070 | 59000 | 01011001000000000000 | CONST R4 #0 ; 
0071 | 59400 | 01011001010000000000 | CONST R5 #0 ; 
0072 | 40016 | 01000000000000010110 | JSR MULT_SR ; Mult result in R1 R2 
0073 | 40034 | 01000000000000110100 | JSR MOD_SR ; Mod result in R0 
0074 | 3E400 | 00111110010000000000 | ADD R25 R0 #0 ; Y1 <- Y3 
0075 | 389A0 | 00111000100110100000 | ADD R2 R13 #0 ; R2 <- F 
0076 | 38DC0 | 00111000110111000000 | ADD R3 R14 #0 ; R2 <- G 
0077 | 59000 | 01011001000000000000 | CONST R4 #0 ; 
0078 | 59400 | 01011001010000000000 | CONST R5 #0 ; 
0079 | 4000F | 01000000000000001111 | JSR MULT_SR ; Mult result in R1 R2 
007a | 4002D | 01000000000000101101 | JSR MOD_SR ; Mod result in R0 
007b | 3E800 | 00111110100000000000 | ADD R26 R0 #0 ; Z1 <- Z3 
007c | 38980 | 00111000100110000000 | ADD R2 R12 #0 ; R2 <- E 
007d | 38DE0 | 00111000110111100000 | ADD R3 R15 #0 ; R2 <- H 
007e | 59000 | 01011001000000000000 | CONST R4 #0 ; 
007f | 59400 | 01011001010000000000 | CONST R5 #0 ; 
0080 | 40008 | 01000000000000001000 | JSR MULT_SR ; Mult result in R1 R2 
0081 | 40026 | 01000000000000100110 | JSR MOD_SR ; Mod result in R0 
0082 | 3EC00 | 00111110110000000000 | ADD R27 R0 #0 ; T1 <- T3 
0083 | 39EC0 | 00111001111011000000 | ADD R7 R22 #0 ; Rest PC of RET 
0084 | 3E300 | 00111110001100000000 | ADD R24 R24 #0 ; printing for debuging 
0085 | 3E720 | 00111110011100100000 | ADD R25 R25 #0 ; printing for debuging 
0086 | 3EB40 | 00111110101101000000 | ADD R26 R26 #0 ; printing for debuging 
0087 | 3EF60 | 00111110111101100000 | ADD R27 R27 #0 ; printing for debuging 
0088 | 50000 | 01010000000000000000 | RTI ; Return 
0089 | 59800 | 01011001100000000000 | CONST R6 #0 ; R6 <- 0 Both P or Both N 
008a | 99080 | 10011001000010000000 | CHKH R4 ; R2 zp 
008b | 08005 | 00001000000000000101 | BRz LBL_R3 ; if r2 is 0 or pos then branch 
008c | A0840 | 10100000100001000000 | TCS R2 R2 ; R2 is negative so invert 
008d | 994A0 | 10011001010010100000 | CHKH R5 ; is R3 0 or pos 
008e | 08005 | 00001000000000000101 | BRz LBL_R2N ; if R3 is 0 then branch 
008f | A0C60 | 10100000110001100000 | TCS R3 R3 ; R3 is negative so invert 
0090 | 10004 | 00010000000000000100 | BRzp LBL_MULT ; flipped both so can go straight to mult 
0091 | 994A0 | 10011001010010100000 | CHKH R5 ; R2 is 0 or pos need to check R3 
0092 | 08002 | 00001000000000000010 | BRz LBL_MULT ; if r3 is also 0 or pos 
0093 | A0C60 | 10100000110001100000 | TCS R3 R3 ; r3 is negative so invert 
0094 | 59801 | 01011001100000000001 | CONST R6 #1 ; need to set flag to invert at the end only one was neg 
0095 | 580FF | 01011000000011111111 | CONST R0 #255 
0096 | 38001 | 00111000000000000001 | ADD R0 R0 #1 ; N = 256 
0097 | 38420 | 00111000010000100000 | ADD R1 R1 #0 
0098 | 38840 | 00111000100001000000 | ADD R2 R2 #0 
0099 | 58400 | 01011000010000000000 | CONST R1 #0 ; A = 0; 
009a | 59000 | 01011001000000000000 | CONST R4 #0 
009b | 80840 | 10000000100001000000 | CHKL R2 ; Check lowest bit of Q 
009c | 08002 | 00001000000000000010 | BRz LBL_F ; Yes/No 
009d | 28423 | 00101000010000100011 | ADD R1 R1 R3 ; A <- A + B 
009e | B9000 | 10111001000000000000 | GCAR R4 
009f | 78822 | 01111000100000100010 | SDRL R2 R1 R2 ; Shift A_Q right 
00a0 | 78481 | 01111000010010000001 | SDRL R1 R4 R1 ; Shift A_Q right 
00a1 | 3801F | 00111000000000011111 | ADD R0 R0 #-1 ; N <- N - 1 
00a2 | 181F7 | 00011000000111110111 | BRnp CHECK_SR ; N == 0? 
00a3 | 998C0 | 10011001100011000000 | CHKH R6 ; is R0 0 or 1 
00a4 | 08002 | 00001000000000000010 | BRz LBL_END_MULT 
00a5 | A0840 | 10100000100001000000 | TCS R2 ; R2 is low bits 
00a6 | A8420 | 10101000010000100000 | TCDH R1 ; R1 is high bits 
00a7 | 50000 | 01010000000000000000 | RTI ; Return 
00a8 | 59400 | 01011001010000000000 | CONST R5 #0 ; erase state 
00a9 | 98420 | 10011000010000100000 | CHKH R1 ; R1 zp 
00aa | 10003 | 00010000000000000011 | BRzp LBL_MOD 
00ab | A0840 | 10100000100001000000 | TCS R2 
00ac | A8420 | 10101000010000100000 | TCDH R1 
00ad | 59401 | 01011001010000000001 | CONST R5 #1 ; need to set flag to invert at the end only one was neg 
00ae | 90422 | 10010000010000100010 | SDL R1 R1 R2 ; split into 257 and 255 
00af | 60841 | 01100000100001000001 | SLL R2 R2 #1 
00b0 | 68841 | 01101000100001000001 | SRL R2 R2 #1 ; ^ and this clear out top bit 
00b1 | 58C00 | 01011000110000000000 | CONST R3 #0 
00b2 | 38020 | 00111000000000100000 | ADD R0 R1 #0 ; R0 <- p 
00b3 | 39020 | 00111001000000100000 | ADD R4 R1 #0 ; R4 <- p 
00b4 | 29022 | 00101001000000100010 | ADD R4 R1 R2 ; {carry R4} <- p + r 
00b5 | B0C60 | 10110000110001100000 | ADDc R3 R3 ; R3 = R3 + carry 
00b6 | 60404 | 01100000010000000100 | SLL R1 R0 #4 ; R1 <- p[WORD_SIZE-5:0] 
00b7 | 29024 | 00101001000000100100 | ADD R4 R1 R4 ; {carry R4} <- R4 + p[WORD_SIZE-5:0] 
00b8 | B0C60 | 10110000110001100000 | ADDc R3 R3 ; R3 = R3 + carry 
00b9 | 60401 | 01100000010000000001 | SLL R1 R0 #1 ; R1 <- p[WORD_SIZE-2:0] 
00ba | 29024 | 00101001000000100100 | ADD R4 R1 R4 ; {carry R4} <- R4 + p[WORD_SIZE-1:0] 
00bb | B0C60 | 10110000110001100000 | ADDc R3 R3 ; R3 = R3 + carry 
00bc | 6840E | 01101000010000001110 | SRL R1 R0 #14 ; R1 = p[WORD_SIZE-2:WORD_SIZE-5] 
00bd | 28C23 | 00101000110000100011 | ADD R3 R1 R3 ; R3 = R3 + p[WORD_SIZE-2:WORD_SIZE-5] 
00be | 6840F | 01101000010000001111 | SRL R1 R0 #15 ; R1 = p[WORD_SIZE-2] 
00bf | 28C23 | 00101000110000100011 | ADD R3 R1 R3 ; R3 = R3 + p[WORD_SIZE-2] 
00c0 | 38880 | 00111000100010000000 | ADD R2 R4 #0 ; R2 = R4 
00c1 | 38460 | 00111000010001100000 | ADD R1 R3 #0 ; R1 = R3 
00c2 | 181EB | 00011000000111101011 | BRnp LBL_MOD ; If top bits aren't empty then need to run mod again 
00c3 | 38200 | 00111000001000000000 | ADD R0 R16 #0 
00c4 | 31002 | 00110001000000000010 | SUB R4 R0 R2 ; Check if R16 > R2 
00c5 | 201E8 | 00100000000111101000 | BRnz LBL_MOD 
00c6 | 38040 | 00111000000001000000 | ADD R0 R2 #0 ; Move result into R0 
00c7 | 814A0 | 10000001010010100000 | CHKL R5 ; is R0 0 or 1 
00c8 | 08003 | 00001000000000000011 | BRz LBL_END_MOD 
00c9 | 38800 | 00111000100000000000 | ADD R2 R0 #0 
00ca | 38600 | 00111000011000000000 | ADD R1 R16 #0 
00cb | 30022 | 00110000000000100010 | SUB R0 R1 R2 
00cc | 50000 | 01010000000000000000 | RTI ; Result placed in R0 TODO need to add signed and 255 bit split 
